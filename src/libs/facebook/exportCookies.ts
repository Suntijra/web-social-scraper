/* eslint-disable no-console */

import fs from 'node:fs'
import path from 'node:path'

import {
  chromium,
  firefox,
  webkit,
  type Browser,
  type BrowserContext,
  type Cookie,
  type Locator,
  type Page,
} from 'playwright'

import { appConfig } from './config'

const EMAIL_ENV_KEY = 'FACEBOOK_EMAIL'
const PASSWORD_ENV_KEY = 'FACEBOOK_PASSWORD'
const OUTPUT_ENV_KEY = 'FACEBOOK_COOKIES_PATH'

type SupportedBrowser = 'chromium' | 'firefox' | 'webkit'
type BrowserLauncher = () => Promise<Browser>

const NETSCAPE_HEADER = '# Netscape HTTP Cookie File\n# Generated by src/libs/facebook/exportCookies.ts\n'
const DEFAULT_OUTPUT = path.resolve(process.cwd(), 'facebook/facebook_cookies.txt')

const browserLaunchers: Record<SupportedBrowser, BrowserLauncher> = {
  chromium: () => chromium.launch({ headless: false }),
  firefox: () => firefox.launch({ headless: false }),
  webkit: () => webkit.launch({ headless: false }),
}

const ensureDirectory = (filePath: string): void => {
  fs.mkdirSync(path.dirname(filePath), { recursive: true })
}

const toBooleanFlag = (value: boolean): 'TRUE' | 'FALSE' => (value ? 'TRUE' : 'FALSE')

const formatExpires = (cookie: Cookie): number => {
  if (typeof cookie.expires === 'number' && Number.isFinite(cookie.expires) && cookie.expires > 0) {
    return Math.floor(cookie.expires)
  }
  return Math.floor(Date.now() / 1000) + 365 * 24 * 60 * 60
}

const serializeCookie = (cookie: Cookie): string => {
  const domain = cookie.domain.startsWith('.') ? cookie.domain : `.${cookie.domain}`
  const includeSubdomains = domain.startsWith('.') || cookie.domain.startsWith('.')
  const secure = Boolean(cookie.secure)
  const pathValue = cookie.path ?? '/'
  const expires = formatExpires(cookie)
  return [
    domain,
    toBooleanFlag(includeSubdomains),
    pathValue,
    toBooleanFlag(secure),
    expires,
    cookie.name,
    cookie.value,
  ].join('\t')
}

const writeCookiesFile = (cookies: Cookie[], outputPath: string): string => {
  const sortedCookies = cookies
    .filter((cookie) => cookie.domain.includes('facebook.com'))
    .sort((a, b) => a.name.localeCompare(b.name))

  if (sortedCookies.length === 0) {
    throw new Error('No facebook.com cookies were captured. Did the login flow complete successfully?')
  }

  ensureDirectory(outputPath)
  fs.writeFileSync(
    outputPath,
    NETSCAPE_HEADER + sortedCookies.map((cookie) => serializeCookie(cookie)).join('\n'),
    'utf8'
  )
  return outputPath
}

const launchBrowser = async (): Promise<Browser> => {
  const launcher = browserLaunchers[appConfig.browser] ?? browserLaunchers.chromium
  if (appConfig.headless) {
    console.warn('PLAYWRIGHT_HEADLESS=true detected. Overriding to false for interactive login.')
  }
  return launcher()
}

const openContext = async (): Promise<{ context: BrowserContext; browser?: Browser }> => {
  if (appConfig.userDataDir && appConfig.browser === 'chromium') {
    fs.mkdirSync(appConfig.userDataDir, { recursive: true })
    const context = await chromium.launchPersistentContext(appConfig.userDataDir, { headless: false })
    return { context }
  }

  if (!appConfig.storageStatePath) {
    throw new Error('Set PLAYWRIGHT_STORAGE_PATH or PLAYWRIGHT_USER_DATA_DIR to capture a reusable Facebook session.')
  }

  const browser = await launchBrowser()
  const context = fs.existsSync(appConfig.storageStatePath)
    ? await browser.newContext({ storageState: appConfig.storageStatePath })
    : await browser.newContext()
  return { context, browser }
}

const randomDelay = (min = 60, max = 160): number => min + Math.floor(Math.random() * (max - min + 1))

const typeLikeHuman = async (locator: Locator, text: string): Promise<void> => {
  await locator.focus()
  await locator.fill('')
  for (const char of text) {
    await locator.type(char, { delay: randomDelay() })
  }
}

const tryAutoLogin = async (page: Page, context: BrowserContext): Promise<boolean> => {
  const email = process.env[EMAIL_ENV_KEY]
  const password = process.env[PASSWORD_ENV_KEY]
  if (!email || !password) {
    console.log('FACEBOOK_EMAIL and FACEBOOK_PASSWORD not set. Proceeding with cached session or manual login.')
    return false
  }

  const findLoginField = async (): Promise<Locator | null> => {
    const selectors = ['input[name="email"]', 'input#email']
    for (const selector of selectors) {
      const locator = page.locator(selector).first()
      if ((await locator.count()) > 0) {
        return locator
      }
    }
    return null
  }

  let emailField = await findLoginField()
  if (!emailField) {
    console.log('Login form not detected, navigating to explicit login page.')
    await page.goto('https://www.facebook.com/login.php', { waitUntil: 'domcontentloaded' })
    emailField = await findLoginField()
  }

  if (!emailField) {
    console.warn('Unable to locate the Facebook login email field automatically. Please log in manually.')
    return false
  }

  const passwordField = page.locator('input[name="pass"], input#pass').first()
  if ((await passwordField.count()) === 0) {
    console.warn('Password field not found. Please complete login manually.')
    return false
  }

  console.log('Attempting automatic login using FACEBOOK_EMAIL / FACEBOOK_PASSWORD...')
  await typeLikeHuman(emailField, email)
  await typeLikeHuman(passwordField, password)

  const loginButton = page.locator('button[name="login"], button[type="submit"]').first()
  const hasLoginButton = (await loginButton.count()) > 0

  if (hasLoginButton) {
    try {
      await Promise.all([
        page.waitForNavigation({ waitUntil: 'networkidle', timeout: 30_000 }).catch(() => undefined),
        loginButton.click({ delay: randomDelay(120, 220) }),
      ])
    } catch (error) {
      console.warn('Navigation did not complete after clicking login button:', error)
    }
  } else {
    console.warn('Login button not found. Continuing without click; please verify manually if requested.')
  }

  await page.waitForTimeout(4_000)

  const cookies = await context.cookies()
  const hasSession = cookies.some((cookie) => cookie.name === 'c_user')

  if (hasSession) {
    console.log('Auto login succeeded (detected c_user cookie).')
    return true
  }

  console.warn('Auto login may have failed. Please verify in the browser window if prompted.')
  return false
}

export interface ExportCookiesOptions {
  targetUrl?: string
  outputPath?: string
  logger?: Pick<Console, 'log' | 'warn' | 'error'>
}

export const exportFacebookCookies = async (options: ExportCookiesOptions = {}): Promise<string> => {
  const targetUrl = options.targetUrl ?? appConfig.targetUrl ?? 'https://www.facebook.com/'
  const configuredOutput = process.env[OUTPUT_ENV_KEY]
  const outputPath =
    options.outputPath ?? (configuredOutput ? path.resolve(process.cwd(), configuredOutput) : DEFAULT_OUTPUT)
  const logger = options.logger ?? console

  const { context, browser } = await openContext()
  const page = await context.newPage()

  try {
    logger.log(`Navigating to ${targetUrl}`)
    await page.goto(targetUrl, { waitUntil: 'domcontentloaded', timeout: appConfig.navigationTimeoutMs })
    await tryAutoLogin(page, context)

    const cookies = await context.cookies()
    const savedPath = writeCookiesFile(cookies, outputPath)
    logger.log(`Saved ${cookies.length} cookies to ${savedPath}`)

    if (!appConfig.userDataDir && appConfig.storageStatePath) {
      await context.storageState({ path: appConfig.storageStatePath })
      logger.log(`Updated storage state at ${appConfig.storageStatePath}`)
    }

    return savedPath
  } finally {
    await page.close()
    await context.close()
    if (browser) {
      await browser.close()
    }
  }
}

if (import.meta.main) {
  const target = process.argv[2]
  const output = process.argv[3]
  void exportFacebookCookies({
    targetUrl: target,
    outputPath: output ? path.resolve(process.cwd(), output) : undefined,
  }).catch((error) => {
    console.error('Failed to export Facebook cookies:')
    console.error(error)
    process.exitCode = 1
  })
}
