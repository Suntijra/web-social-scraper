/* eslint-disable no-console */

import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'

import {
  chromium,
  firefox,
  webkit,
  type Browser,
  type BrowserContext,
  type Cookie,
  type Locator,
  type Page,
} from 'playwright'

import { envVariables } from '#factory'

import { appConfig } from './config'

const HEADFUL_OVERRIDE_ENV_KEY = 'FACEBOOK_COOKIES_HEADFUL'

type SupportedBrowser = 'chromium' | 'firefox' | 'webkit'
type BrowserLauncher = (options: { headless: boolean }) => Promise<Browser>

const NETSCAPE_HEADER = '# Netscape HTTP Cookie File\n# Generated by src/libs/facebook/exportCookies.ts\n'
const DEFAULT_OUTPUT = path.resolve(process.cwd(), 'facebook/facebook_cookies.txt')

const browserLaunchers: Record<SupportedBrowser, BrowserLauncher> = {
  chromium: ({ headless }) =>
    chromium.launch({
      headless,
      args: headless ? ['--disable-gpu', '--disable-dev-shm-usage', '--no-sandbox'] : undefined,
    }),
  firefox: ({ headless }) => firefox.launch({ headless }),
  webkit: ({ headless }) => webkit.launch({ headless }),
}

type ExportLogger = Pick<Console, 'log' | 'warn' | 'error'>

const ensureDirectory = (filePath: string): void => {
  fs.mkdirSync(path.dirname(filePath), { recursive: true })
}

const toBooleanFlag = (value: boolean): 'TRUE' | 'FALSE' => (value ? 'TRUE' : 'FALSE')

const formatExpires = (cookie: Cookie): number => {
  if (typeof cookie.expires === 'number' && Number.isFinite(cookie.expires) && cookie.expires > 0) {
    return Math.floor(cookie.expires)
  }
  return Math.floor(Date.now() / 1000) + 365 * 24 * 60 * 60
}

const serializeCookie = (cookie: Cookie): string => {
  const domain = cookie.domain.startsWith('.') ? cookie.domain : `.${cookie.domain}`
  const includeSubdomains = domain.startsWith('.') || cookie.domain.startsWith('.')
  const secure = Boolean(cookie.secure)
  const pathValue = cookie.path ?? '/'
  const expires = formatExpires(cookie)
  return [
    domain,
    toBooleanFlag(includeSubdomains),
    pathValue,
    toBooleanFlag(secure),
    expires,
    cookie.name,
    cookie.value,
  ].join('\t')
}

const writeCookiesFile = (cookies: Cookie[], outputPath: string): string => {
  const sortedCookies = cookies
    .filter((cookie) => cookie.domain.includes('facebook.com'))
    .sort((a, b) => a.name.localeCompare(b.name))

  if (sortedCookies.length === 0) {
    throw new Error('No facebook.com cookies were captured. Did the login flow complete successfully?')
  }

  ensureDirectory(outputPath)
  fs.writeFileSync(
    outputPath,
    NETSCAPE_HEADER + sortedCookies.map((cookie) => serializeCookie(cookie)).join('\n'),
    'utf8'
  )
  return outputPath
}

const truthyValues = new Set(['1', 'true', 'yes', 'on'])
const parseBooleanFlag = (value: string | undefined): boolean => {
  if (!value) {
    return false
  }
  return truthyValues.has(value.toLowerCase())
}

const hasLoginCredentials = (): boolean => {
  return Boolean(envVariables.FACEBOOK_EMAIL && envVariables.FACEBOOK_PASSWORD)
}

const hasReusableSession = (): boolean => {
  if (appConfig.userDataDir) {
    try {
      if (fs.existsSync(appConfig.userDataDir)) {
        const files = fs.readdirSync(appConfig.userDataDir)
        if (files.length > 0) {
          return true
        }
      }
    } catch {
      /* ignore */
    }
  }
  if (appConfig.storageStatePath && fs.existsSync(appConfig.storageStatePath)) {
    return true
  }
  return false
}

const resolveHeadlessDecision = (): { headless: boolean; reason?: string } => {
  if (parseBooleanFlag(envVariables.FACEBOOK_COOKIES_HEADFUL)) {
    return { headless: false, reason: `${HEADFUL_OVERRIDE_ENV_KEY}=1` }
  }

  const desiredHeadless = parseBooleanFlag(envVariables.FACEBOOK_COOKIES_HEADLESS) || appConfig.headless
  if (!desiredHeadless) {
    return { headless: false, reason: 'PLAYWRIGHT_HEADLESS disabled' }
  }

  if (!hasLoginCredentials() && !hasReusableSession()) {
    return {
      headless: false,
      reason: 'headless login requires FACEBOOK_EMAIL/PASSWORD or existing storage state',
    }
  }
  return { headless: true }
}

const launchBrowser = async (headless: boolean, logger: ExportLogger): Promise<Browser> => {
  const launcher = browserLaunchers[appConfig.browser] ?? browserLaunchers.chromium
  if (!headless && appConfig.headless) {
    logger.warn('PLAYWRIGHT_HEADLESS=true detected. Overriding to false for interactive login.')
  }
  return launcher({ headless })
}

const openContext = async (
  headless: boolean,
  logger: ExportLogger
): Promise<{ context: BrowserContext; browser?: Browser }> => {
  if (appConfig.userDataDir && appConfig.browser === 'chromium') {
    fs.mkdirSync(appConfig.userDataDir, { recursive: true })
    const context = await chromium.launchPersistentContext(appConfig.userDataDir, {
      headless,
      args: headless ? ['--disable-gpu', '--disable-dev-shm-usage', '--no-sandbox'] : undefined,
    })
    return { context }
  }

  if (!appConfig.storageStatePath) {
    throw new Error('Set PLAYWRIGHT_STORAGE_PATH or PLAYWRIGHT_USER_DATA_DIR to capture a reusable Facebook session.')
  }

  const browser = await launchBrowser(headless, logger)
  const context = fs.existsSync(appConfig.storageStatePath)
    ? await browser.newContext({ storageState: appConfig.storageStatePath })
    : await browser.newContext()

  if (!headless) {
    logger.warn('Facebook cookie export is running in headful mode. A browser window may open if needed.')
  }
  return { context, browser }
}

const randomDelay = (min = 60, max = 160): number => min + Math.floor(Math.random() * (max - min + 1))

const typeLikeHuman = async (locator: Locator, text: string): Promise<void> => {
  await locator.focus()
  await locator.fill('')
  for (const char of text) {
    await locator.type(char, { delay: randomDelay() })
  }
}

const tryAutoLogin = async (page: Page, context: BrowserContext): Promise<boolean> => {
  const email = envVariables.FACEBOOK_EMAIL
  const password = envVariables.FACEBOOK_PASSWORD
  if (!email || !password) {
    console.log('FACEBOOK_EMAIL and FACEBOOK_PASSWORD not set. Proceeding with cached session or manual login.')
    return false
  }

  const findLoginField = async (): Promise<Locator | null> => {
    const selectors = ['input[name="email"]', 'input#email']
    for (const selector of selectors) {
      const locator = page.locator(selector).first()
      if ((await locator.count()) > 0) {
        return locator
      }
    }
    return null
  }

  let emailField = await findLoginField()
  if (!emailField) {
    console.log('Login form not detected, navigating to explicit login page.')
    await page.goto('https://www.facebook.com/login.php', { waitUntil: 'domcontentloaded' })
    emailField = await findLoginField()
  }

  if (!emailField) {
    console.warn('Unable to locate the Facebook login email field automatically. Please log in manually.')
    return false
  }

  const passwordField = page.locator('input[name="pass"], input#pass').first()
  if ((await passwordField.count()) === 0) {
    console.warn('Password field not found. Please complete login manually.')
    return false
  }

  console.log('Attempting automatic login using FACEBOOK_EMAIL / FACEBOOK_PASSWORD...')
  await typeLikeHuman(emailField, email)
  await typeLikeHuman(passwordField, password)

  const loginButton = page.locator('button[name="login"], button[type="submit"]').first()
  const hasLoginButton = (await loginButton.count()) > 0

  if (hasLoginButton) {
    try {
      await Promise.all([
        page.waitForNavigation({ waitUntil: 'networkidle', timeout: 30_000 }).catch(() => undefined),
        loginButton.click({ delay: randomDelay(120, 220) }),
      ])
    } catch (error) {
      console.warn('Navigation did not complete after clicking login button:', error)
    }
  } else {
    console.warn('Login button not found. Continuing without click; please verify manually if requested.')
  }

  await page.waitForTimeout(4_000)

  const cookies = await context.cookies()
  const hasSession = cookies.some((cookie) => cookie.name === 'c_user')

  if (hasSession) {
    console.log('Auto login succeeded (detected c_user cookie).')
    return true
  }

  console.warn('Auto login may have failed. Please verify in the browser window if prompted.')
  return false
}

interface ExportCookiesOptions {
  targetUrl?: string
  outputPath?: string
  headless?: boolean
  logger?: ExportLogger
}

export const exportFacebookCookies = async (options: ExportCookiesOptions = {}): Promise<string> => {
  const targetUrl = options.targetUrl ?? appConfig.targetUrl ?? 'https://www.facebook.com/'
  const configuredOutput =
    envVariables.NODE_ENV === 'production' ? envVariables.FACEBOOK_COOKIES_PATH : './facebook/facebook_cookies.txt'
  const outputPath =
    options.outputPath ?? (configuredOutput ? path.resolve(process.cwd(), configuredOutput) : DEFAULT_OUTPUT)
  const logger = options.logger ?? console

  const decision = resolveHeadlessDecision()
  const headless = options.headless ?? decision.headless

  if (headless) {
    logger.log('Running Facebook cookie export in headless mode.')
  } else if (decision.reason) {
    logger.log(`Running Facebook cookie export in headful mode (${decision.reason}).`)
  } else {
    logger.log('Running Facebook cookie export in headful mode.')
  }

  const { context, browser } = await openContext(headless, logger)
  const page = await context.newPage()

  try {
    logger.log(`Navigating to ${targetUrl}`)
    await page.goto(targetUrl, { waitUntil: 'domcontentloaded', timeout: appConfig.navigationTimeoutMs })
    await tryAutoLogin(page, context)

    const cookies = await context.cookies()
    const savedPath = writeCookiesFile(cookies, outputPath)
    logger.log(`Saved ${cookies.length} cookies to ${savedPath}`)

    if (headless) {
      const hasSession = cookies.some((cookie) => cookie.name === 'c_user')
      if (!hasSession) {
        throw new Error(
          'Headless cookie export did not capture c_user cookie. Set FACEBOOK_COOKIES_HEADFUL=1 and rerun to log in manually.'
        )
      }
    }

    if (!appConfig.userDataDir && appConfig.storageStatePath) {
      await context.storageState({ path: appConfig.storageStatePath })
      logger.log(`Updated storage state at ${appConfig.storageStatePath}`)
    }

    return savedPath
  } finally {
    await page.close()
    await context.close()
    if (browser) {
      await browser.close()
    }
  }
}

const resolveCliInvocation = (): { targetUrl?: string; outputPath?: string } | null => {
  if (!process.argv[1]) {
    return null
  }
  const modulePath = fileURLToPath(import.meta.url)
  const entryPath = path.resolve(process.argv[1])
  if (entryPath !== modulePath) {
    return null
  }
  const args = process.argv.slice(2).filter((arg) => arg !== undefined)
  const sanitizedArgs = args[0] === '--' ? args.slice(1) : args
  const targetUrl = sanitizedArgs[0]
  const outputArg = sanitizedArgs[1]
  return {
    targetUrl,
    outputPath: outputArg ? path.resolve(process.cwd(), outputArg) : undefined,
  }
}

const cliInvocation = resolveCliInvocation()
if (cliInvocation) {
  void exportFacebookCookies(cliInvocation).catch((error) => {
    console.error('Failed to export Facebook cookies:')
    console.error(error)
    process.exitCode = 1
  })
}
